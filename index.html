<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Почти готовая страница</title>
  <style>
    /* Ваши существующие стили */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f4f4f4;
      color: #333;
    }

    h1 {
      color: #0056b3;
      text-align: center;
      margin-bottom: 30px;
    }

    h2 {
      color: #0069d9;
      text-align: center;
      margin-top: 40px;
      margin-bottom: 20px;
    }

    table {
      width: 500px;
      /* Остается для первой таблицы */
      margin: 10px auto;
      border-collapse: collapse;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      background-color: #fff;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: center;
    }

    th {
      background-color: #007bff;
      color: white;
      text-transform: uppercase;
      font-weight: bold;
    }

    tr:nth-child(even) {
      background-color: #f8f8f8;
    }

    tr:hover {
      background-color: #e9ecef;
    }

    .button-container {
      text-align: center;
      margin-top: 40px;
      margin-bottom: 20px;
      /* Добавляем flexbox для кнопок, чтобы они могли располагаться вертикально на любом экране */
      display: flex;
      flex-direction: column;
      /* Располагаем элементы в колонку */
      align-items: center;
      /* Центрируем по горизонтали */
      gap: 15px;
      /* Добавляем промежуток между кнопками */
    }

    .action-button {
      background-color: #28a745;
      color: white;
      padding: 15px 30px;
      border: none;
      border-radius: 5px;
      font-size: 18px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      /* Убираем фиксированный margin, используем gap в button-container */
      /* margin: 0 10px; */
      width: 200px;
      /* Фиксированная ширина для кнопок */
      max-width: 90%;
      /* Но не более 90% ширины родителя */
    }

    .action-button:hover {
      background-color: #218838;
    }

    .save-button {
      background-color: #007bff;
    }

    .save-button:hover {
      background-color: #0056b3;
    }

    /* --- СТИЛИ ДЛЯ ВТОРОЙ ТАБЛИЦЫ --- */
    .schedule-table {
      width: 300px;
      /* Фиксированная очень маленькая ширина */
      margin: 5px auto;
      /* Центрируем */
      border-collapse: collapse;
      box-shadow: 0 2px 1px rgba(0, 0, 0, 0.1);
      background-color: #fff;
      table-layout: fixed;
      /* Важно, чтобы ширина колонок соблюдалась */
    }

    /* Применяем ширину к заголовкам и ячейкам второй таблицы */
    .schedule-table th,
    .schedule-table td {
      padding: 8px 3px;
      /* Уменьшаем паддинг для компактности */
      font-size: 0.8em;
      /* Уменьшаем размер шрифта */
    }

    .schedule-table td:nth-child(1) {
      width: 160px;
      /* Ширина для колонки "Время" */
    }

    .schedule-table td:nth-child(2) {
      width: 140px;
      /* Ширина для колонки "Количество" */
    }

    /* Общие стили для всех input-полей внутри редактируемых ячеек */
    .schedule-table input {
      width: 140px;
      /* Занимает почти всю ширину ячейки */
      box-sizing: border-box;
      padding: 3px;
      /* Уменьшаем паддинг */
      border: 1px solid #ccc;
      border-radius: 3px;
      text-align: center;
      font-size: inherit;
    }

    /* *** ИСПРАВЛЕННЫЕ СТИЛИ: ПРИМЕНЯЮТСЯ ТОЛЬКО КОГДА ТАБЛИЦА В РЕЖИМЕ РЕДАКТИРОВАНИЯ *** */
    .schedule-table.edit-mode-active td:nth-child(1) {
      width: 140px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1;
      /* Убираем padding у ячейки для максимального использования пространства */
    }

    .schedule-table.edit-mode-active td:nth-child(1) input {
      width: 50px;
      /* Каждое поле займет 45% ширины, чтобы поместился разделитель */
      margin: 0 1%;
      /* Небольшой горизонтальный отступ между полями */
      padding: 3px;
      /* Уменьшаем паддинг внутри инпута */
    }

    .schedule-table.edit-mode-active td:nth-child(1) span.time-separator {
      display: inline-block;
      width: 4px;
      /* Корректируем ширину двоеточия */
      text-align: center;
      font-weight: bold;
      font-size: 1em;
      /* Уменьшаем размер шрифта двоеточия */
    }
  </style>
</head>

<body>

  <h1>Питание для друга</h1>

  <h2>Текущее состояние</h2>
  <table>
    <thead>
      <tr>
        <th>Температура</th>
        <th>Влажность</th>
        <th>Напряжение</th>
        <th>Средний ток последнего цикла</th>
        <th>Время последнего цикла</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td id="tempValue">--</td>
        <td id="humidityValue">--</td>
        <td id="voltageValue">--</td>
        <td id="currentValue">--</td>
        <td id="fullTimeValue">--</td>
      </tr>
      <tr>
        <td>°С</td>
        <td>­%</td>
        <td>В</td>
        <td>mA</td>
        <td id="statusMessage">--</td>
      </tr>
    </tbody>
  </table>

  <h2>Расписание</h2>
  <table class="schedule-table" id="scheduleTable">
    <thead>
      <tr>
        <th>Время</th>
        <th>Количество</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>--:--</td>
        <td>-</td>
      </tr>
      <tr>
        <td>--:--</td>
        <td>-</td>
      </tr>
      <tr>
        <td>--:--</td>
        <td>-</td>
      </tr>
      <tr>
        <td>--:--</td>
        <td>-</td>
      </tr>
      <tr>
        <td>--:--</td>
        <td>-</td>
      </tr>
      <tr>
        <td>Ручной</td>
        <td>-</td>
      </tr>
    </tbody>
  </table>

  <div class="button-container">
    <button class="action-button" id="editButton">Изменить</button>
    <button class="action-button" id="runButton">Запустить</button>
    <button class="action-button save-button" id="saveButton" style="display: none;">Сохранить</button>
  </div>

  <script>
    const CHANNEL_ID1 = '3002399'; // Например, 123456
    const READ_API_KEY1 = '2R940E9A2PA5O91X'; // Опционально, если канал приватный
    const API_URL1 = `https://api.thingspeak.com/channels/${CHANNEL_ID1}/feeds.json?results=1&api_key=${READ_API_KEY1}`;
    const CHANNEL_ID2 = '3005628'; // Например, 123456
    const READ_API_KEY2 = 'QRE3PONYLRKL3Q4J'; // Опционально, если канал приватный
    const API_URL2 = `https://api.thingspeak.com/channels/${CHANNEL_ID2}/feeds.json?results=5&api_key=${READ_API_KEY2}`; // Изменено на results=5, чтобы получить 5 последних записей
    async function fetchThingSpeakTimers() {
      try {
        const response = await fetch(API_URL2);
        const data = await response.json();
        if (data && data.feeds && data.feeds.length > 0) {
          const rows = scheduleTable.querySelectorAll('tbody tr'); // Получаем все строки таблицы расписания
          const latestFeed = data.feeds[0];
          // Предполагаем, что field1, field2, field3, field4, field5 из ThingSpeak
          // содержат значения времени для 5 расписаний.
          const timeValuesFromThingSpeak = [
            latestFeed.field1,
            latestFeed.field2,
            latestFeed.field3,
            latestFeed.field4,
            latestFeed.field5,
            latestFeed.field6
          ];
          for (let i = 0; i < 5; i++) {
            const feed = timeValuesFromThingSpeak[i];
            const scheduleRowIndex = i; // Соответствует первой, второй, ..., пятой строке таблицы
            // Предполагаем, что каждое поле (field1, field2, ...)
            // содержит строку в формате "XЧЧММК"
            const rawDataString = timeValuesFromThingSpeak[i]; // Берем field1 для примера, так как это общий шаблон.
            // Вам нужно будет убедиться, что ThingSpeak отправляет
            // данные для каждого расписания в отдельное поле (field1, field2 и т.д.)
            // или в одном поле, но несколько раз.
            // Если каждое расписание в своем поле, то нужно будет:
            // const rawDataString = feed['field' + (i + 1)]; // Например, field1, field2
            // Или если все 5 расписаний в одном поле, но это маловероятно.
            const hours = feed.substring(1, 3); // Часы
            const minutes = feed.substring(3, 5); // Минуты
            const quantity = feed.charAt(5); // Количество
            // Обновляем ячейку "Время"
            rows[scheduleRowIndex].cells[0].textContent = `${hours}:${minutes}`;
            // Обновляем ячейку "Количество"
            rows[scheduleRowIndex].cells[1].textContent = quantity;
          }
          // Обновляем значение "Количество" для строки "Ручной" (последняя строка)
          // Предполагаем, что "Ручной" режим управляется отдельным полем, например field6,
          // из самой последней записи ThingSpeak.
          rows[5].cells[1].textContent = timeValuesFromThingSpeak[5];
          //document.getElementById('manSet').textContent = timeValuesFromThingSpeak[5] || '-';
        }
      } catch (error) {
        // console.error('Ошибка при получении данных с ThingSpeak (timers):', error);
      }
    }
    async function fetchThingSpeakData() {
      try {
        const response = await fetch(API_URL1);
        const data = await response.json();
        if (data && data.feeds && data.feeds.length > 0) {
          const latestFeed = data.feeds[0];
          // Обновляем значения в таблице
          // Убедитесь, что field1, field2 и т.д. соответствуют вашим полям в ThingSpeak
          document.getElementById('voltageValue').textContent = latestFeed.field1 || 'N/A';
          document.getElementById('currentValue').textContent = latestFeed.field2 || 'N/A';
          document.getElementById('tempValue').textContent = latestFeed.field3 || 'N/A';
          document.getElementById('humidityValue').textContent = latestFeed.field4 || 'N/A';
          const hours = parseInt(latestFeed.field5); // Предполагаем, что field5 - это часы
          const minutes = parseInt(latestFeed.field6); // Предполагаем, что field6 - это минуты
          const formattedHours = String(hours).padStart(2, '0');
          const formattedMinutes = String(minutes).padStart(2, '0');
          timeString = `${formattedHours}:${formattedMinutes}`;
          document.getElementById('fullTimeValue').textContent = timeString;
          const field7Value = parseInt(latestFeed.field7); // Получаем значение из field7
          let statusText; // Объявляем statusText здесь
          switch (field7Value) {
            case 1:
              statusText = 'Исправен';
              break;
            case 2:
              statusText = 'Низкий заряд батареи';
              break;
            case 3:
              statusText = 'Бункер пустой';
              break;
            case 4:
              statusText = 'Перегрузка двигателя';
              break;
            case 5:
              statusText = 'В работе ...';
              break;
            default:
              statusText = 'Неизвестный статус'; // Если значение не 1, 2, 3 или 4
          }
          document.getElementById('statusMessage').textContent = statusText;
        }
      } catch (error) {
        //console.error('Ошибка при получении данных с ThingSpeak1:', error);
      }
    }
    // Вызываем функции при загрузке страницы
    document.addEventListener("DOMContentLoaded", () => {
      fetchThingSpeakData(); // Обновляет первую таблицу
      fetchThingSpeakTimers(); // Обновляет вторую таблицу
    });
    // Настраиваем периодическое обновление
    setInterval(fetchThingSpeakData, 180000); // Обновление первой таблицы каждые 3 минуты
    setInterval(fetchThingSpeakTimers, 60000); // Обновление второй таблицы каждую минуту
    async function ManualStart() {
      WRITE_API_KEY_CHANNEL2 = 'HJ36J3I2BYCMGA1M';
      let baseURL = `https://api.thingspeak.com/update?api_key=${WRITE_API_KEY_CHANNEL2}`;
      let updateURL = baseURL + '&field8=1';
      try {
        const response = await fetch(updateURL);
        const data = await response.text(); // ThingSpeak обычно возвращает число или 0
        if (parseInt(data, 10) > 0) {
          //console.log('Данные расписания успешно отправлены на ThingSpeak. Entry ID:', data);
          alert('Команда отправлена');
        } else if (parseInt(data, 10) === 0) {
          //console.warn('ThingSpeak вернул 0. Возможно, проблема с API ключом или интервалом записи.', data);
          alert('ThingSpeak не подтвердил передачу команды');
        } else {
          //console.error('Ошибка отправки данных на ThingSpeak:', data);
          alert('Ошибка передаче команды. Пожалуйста, попробуйте еще раз.');
        }
      } catch (error) {
        //console.error('Ошибка сети при отправке данных на ThingSpeak:', error);
        alert('Ошибка сети при сохранении расписания. Проверьте подключение.');
      }
    }
    async function sendScheduleDataToThingSpeak(scheduleData) {
      WRITE_API_KEY_CHANNEL2 = 'HJ36J3I2BYCMGA1M';
      // Базовый URL для записи на ThingSpeak
      let baseURL = `https://api.thingspeak.com/update?api_key=${WRITE_API_KEY_CHANNEL2}`;
      let updateURL = baseURL;
      // ThingSpeak позволяет отправить до 8 полей в одном запросе.
      // Мы будем формировать строки "XЧЧММК" для каждого расписания (field1-field5)
      // и отправлять "Количество" для ручного режима (field6).
      // Массив для хранения готовых строк "XЧЧММК"
      const formattedScheduleStrings = [];
      // Формируем данные для первых 5 расписаний
      for (let i = 0; i < 5; i++) {
        // Убедитесь, что entry существует и имеет необходимые свойства
        const entry = scheduleData[i];
        // Произвольный нулевой символ 'A' (можно изменить)
        const arbitraryChar = 'T';
        const timeString = `${entry.hours}${entry.minutes}`;
        const quantityString = String(entry.quantity); // Количество - один символ
        // Формируем строку "XЧЧММК"
        formattedScheduleStrings.push(`${arbitraryChar}${timeString}${quantityString}`);
        updateURL += `&field${i + 1}=${encodeURIComponent(formattedScheduleStrings[i])}`;
      }
      // Добавляем значение для ручного режима (field6)
      // Предполагаем, что ручной режим - это последний элемент в scheduleData (индекс 5)
      const manualEntry = scheduleData[5];
      updateURL += `&field6=${encodeURIComponent(manualEntry.quantity)}`;
      updateURL += `&field7=1`;
      //console.log("Отправка на ThingSpeak URL:", updateURL); // Для отладки
      try {
        const response = await fetch(updateURL);
        const data = await response.text(); // ThingSpeak обычно возвращает число или 0
        if (parseInt(data, 10) > 0) {
          //console.log('Данные расписания успешно отправлены на ThingSpeak. Entry ID:', data);
          alert('Расписание успешно сохранено на ThingSpeak!');
        } else if (parseInt(data, 10) === 0) {
          //console.warn('ThingSpeak вернул 0. Возможно, проблема с API ключом или интервалом записи.', data);
          alert('Расписание сохранено, но ThingSpeak вернул 0. Проверьте API ключ или интервал записи.');
        } else {
          //console.error('Ошибка отправки данных на ThingSpeak:', data);
          alert('Ошибка при сохранении расписания на ThingSpeak. Пожалуйста, попробуйте еще раз.');
        }
      } catch (error) {
        //console.error('Ошибка сети при отправке данных на ThingSpeak:', error);
        alert('Ошибка сети при сохранении расписания. Проверьте подключение.');
      }
    }
    // ... ваш существующий JavaScript код после этой части ...
    // ИЗМЕНИТЕ ЭТУ ЧАСТЬ В ОБРАБОТЧИКЕ saveButton.addEventListener('click', ...)
    // --- КОД ДЛЯ РЕДАКТИРОВАНИЯ ТАБЛИЦЫ ---
    const scheduleTable = document.getElementById('scheduleTable');
    const editButton = document.getElementById('editButton');
    const saveButton = document.getElementById('saveButton');
    const runButton = document.getElementById('runButton'); // Кнопка "Запустить"
    let cellOriginalContents = new Map();
    let scheduleData = []; // Переменная для хранения данных расписания
    
    
    editButton.addEventListener('click', () => {
      // Добавляем класс, чтобы активировать стили редактирования
      scheduleTable.classList.add('edit-mode-active');
      const rows = scheduleTable.querySelectorAll('tbody tr');
      cellOriginalContents.clear();
      rows.forEach((row, rowIndex) => {
        const cells = row.querySelectorAll('td');
        // Проверяем, является ли это строкой "Ручной"
        const isLastRowFirstColumnManual = (rowIndex === rows.length - 1 && cells[0].textContent.trim().toLowerCase() === 'ручной');
        // Если это строка "Ручной" и мы находимся в первой колонке, пропускаем ее
        if (isLastRowFirstColumnManual && cells[0] === cells[0]) {
          // Для "Ручной" колонки "Время" просто сохраняем текст, не делаем её редактируемой
          cellOriginalContents.set(cells[0], cells[0].textContent);
        }
        cells.forEach((cell, cellIndex) => {
          if (isLastRowFirstColumnManual && cellIndex === 0) {
            return; // Пропускаем редактирование ячейки "Ручной"
          }
          cellOriginalContents.set(cell, cell.textContent); // Сохраняем исходное содержимое
          if (cellIndex === 0) { // Первый столбец (Время)
            const timeParts = cell.textContent.split(':');
            let hours = parseInt(timeParts[0], 10);
            let minutes = parseInt(timeParts[1], 10);
            if (isNaN(hours)) hours = 0;
            if (isNaN(minutes)) minutes = 0;
            const hourInput = document.createElement('input');
            hourInput.type = 'number';
            hourInput.value = String(hours).padStart(2, '0');
            hourInput.min = '0';
            hourInput.max = '23';
            const minuteInput = document.createElement('input');
            minuteInput.type = 'number';
            minuteInput.value = String(minutes).padStart(2, '0');
            minuteInput.min = '0';
            minuteInput.max = '59';
            const colonSpan = document.createElement('span');
            colonSpan.textContent = ':';
            colonSpan.classList.add('time-separator');
            cell.textContent = ''; // Очищаем ячейку
            cell.appendChild(hourInput);
            cell.appendChild(colonSpan);
            cell.appendChild(minuteInput);
          } else { // Второй столбец (Количество)
            const DoseInput = document.createElement('input');
            DoseInput.type = 'number';
            DoseInput.value = cell.textContent.trim() === '-' ? '0' : cell.textContent; // Если '-', то '0'
            DoseInput.min = '0';
            DoseInput.max = '9'; // Максимум до 9, как вы указали
            cell.textContent = ''; // Очищаем ячейку
            cell.appendChild(DoseInput);
          }
        });
      });
      
      
      
      runButton.addEventListener('click', () => {
     ManualStart();
      });
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      editButton.style.display = 'none';
      runButton.style.display = 'none';
      saveButton.style.display = 'inline-block';
    });
    saveButton.addEventListener('click', () => {
      // ... (ваш существующий код внутри saveButton.addEventListener) ...
      scheduleTable.classList.remove('edit-mode-active');
      const rows = scheduleTable.querySelectorAll('tbody tr');
      const tempScheduleData = [];
      rows.forEach((row, rowIndex) => {
        const cells = row.querySelectorAll('td');
        let currentEntry = {};
        const isLastRowManual = (rowIndex === rows.length - 1 && cells[0].textContent.trim().toLowerCase() === 'ручной');
        if (isLastRowManual) {
          const quantityInput = cells[1].querySelector('input');
          if (quantityInput) {
            currentEntry.quantity = quantityInput.value;
            cells[1].textContent = quantityInput.value;
          } else {
            currentEntry.quantity = cells[1].textContent;
          }
          cells[0].textContent = 'Ручной';
        } else {
          const hourInput = cells[0].querySelector('input[type="number"]:first-of-type');
          const minuteInput = cells[0].querySelector('input[type="number"]:last-of-type');
          const quantityInput = cells[1].querySelector('input');
          if (hourInput && minuteInput) {
            const hours = String(Math.max(0, Math.min(23, parseInt(hourInput.value, 10) || 0))).padStart(2, '0');
            const minutes = String(Math.max(0, Math.min(59, parseInt(minuteInput.value, 10) || 0))).padStart(2, '0');
            currentEntry.hours = hours;
            currentEntry.minutes = minutes;
            cells[0].textContent = `${hours}:${minutes}`;
          } else {
            const timeParts = cells[0].textContent.split(':');
            currentEntry.hours = timeParts[0] || '00';
            currentEntry.minutes = timeParts[1] || '00';
          }
          if (quantityInput) {
            const quantity = String(Math.max(0, Math.min(9, parseInt(quantityInput.value, 10) || 0)));
            currentEntry.quantity = quantity;
            cells[1].textContent = quantity;
          } else {
            currentEntry.quantity = cells[1].textContent;
          }
        }
        tempScheduleData.push(currentEntry);
      });
      scheduleData = tempScheduleData;
      // !!! ДОБАВЛЕННЫЙ ВЫЗОВ ФУНКЦИИ ОТПРАВКИ !!!
      sendScheduleDataToThingSpeak(scheduleData);
      // !!! КОНЕЦ ДОБАВЛЕННОГО ВЫЗОВА !!!
      editButton.style.display = 'inline-block';
      runButton.style.display = 'inline-block';
      saveButton.style.display = 'none';
    });
  </script>

</body>

</html>
